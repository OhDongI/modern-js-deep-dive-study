# 데이터 타입 (Data Type)

## 1. 개요

* 자바스크립트의 모든 값은 데이터 타입(**7개**)을 갖는다.
* **데이터 타입 = 값의 종류**
* 구분: **원시 타입** / **객체 타입**

---

## 2. 원시 타입 (Primitive Type), 객체 타입 (Object/Reference Type)

---

| 구분 | 데이터 타입 | 설명 |
| --- | --- | --- |
| 원시 타입 | 숫자 (number) | 숫자. 정수와 실수 구분 없이 하나의 숫자 타입만 존재 |
| 원시 타입 | 문자열 (string) | 문자열 |
| 원시 타입 | 불리언 (boolean) | 논리적 참과 거짓 |
| 원시 타입 | undefined | var 키워드로 선언된 변수에 암묵적으로 할당되는 값 |
| 원시 타입 | null | 값이 없다는 것을 의도적으로 명시할 때 사용하는 값 |
| 원시 타입 | 심벌(symbol) | ES6에서 추가된 7번째 타입 |
| 객체 타입 |  | 객체, 함수, 배열 등 |

* 자바스크립트를 이루는 대부분은 객체


## 3. 숫자 타입 (Number)

* 자바스크립트는 **하나의 숫자 타입**만 존재 (자바와 달리 int, float 등 없음)
* ECMAScript 사양에 따르면 **64비트 부동소수점 형식** 사용 → 모든 수를 실수로 처리
* 특별한 값 3가지:

  1. `Infinity` : 양의 무한대
  2. `-Infinity` : 음의 무한대
  3. `NaN` : 산술 연산 불가 (Not-A-Number)
* 대소문자 구분 엄격 → `NaN`만 가능 (`nan`, `Nan`, `NAN` 등 오류)

---

## 4. 문자열 타입 (String)

* 텍스트 데이터를 표현
* 작은따옴표(`''`), 큰따옴표(`""`), 백틱(\`\`\`)으로 감쌈

```javascript
var string;
string = '문자열'; // 작은따옴표
string = "문자열"; // 큰따옴표
string = `문자열`; // 백틱 (ES6)
```

* 따옴표로 감싸지 않으면 키워드/식별자로 인식됨 → 에러 발생

```javascript
// 따옴표로 감싸지 않은 hello를 식별자로 인식한다.
var string = hello; // ReferenceError: hello is not defined
```

### 템플릿 리터럴 (Template Literal) - ES6

- 백틱(```)으로 감쌈
- 주요 기능:
    - 멀티라인 문자열
    - 표현식 삽입 (`${ }`)
    - 태그드 템플릿

```jsx
var template = `Template literal`;
console.log(template);

```

---

### 멀티라인 문자열

- 일반 문자열에서는 줄바꿈 불가 → 에러 발생

```jsx
var str = 'Hello
world.';
// SyntaxError

```

> 일반 문자열에서 줄바꿈 등은 이스케이프 시퀀스를 사용해야 함
> 

---

### 이스케이프 시퀀스 (Escape Sequence)

| 표기 | 의미 |
| --- | --- |
| `\0` | Null |
| `\b` | 백스페이스 |
| `\f` | 폼 피드 |
| `\n` | 개행 (Line Feed) |
| `\r` | 개행 (Carriage Return) |
| `\t` | 수평 탭 |
| `\v` | 수직 탭 |
| `\uXXXX` | 유니코드 |
| `'` | 작은따옴표 |
| `"` | 큰따옴표 |
| `\\` | 백슬래시 |

```jsx
var template = '<ul>\n\t<li><a href="#">Home</a></li></ul>';
console.log(template);

```

출력 결과:

```html
<ul>
	<li><a href="#">Home</a></li>
</ul>

```

---

### 템플릿 리터럴에서 멀티라인 문자열

- 줄바꿈 및 공백을 그대로 표현 가능
- 이스케이프 시퀀스 없이 사용 가능

```jsx
var template = `<ul>
	<li><a href="#">Home</a></li>
</ul>`;

console.log(template);

```

---

### 표현식 삽입

- `+` 연산자는 피연산자 중 하나 이상이 문자열이면 문자열 연결 연산자로 동작

```jsx
var first = "dongi";
var last = "Oh";

// ES5: 문자열 연결
console.log('My name is ' + first + ' ' + last + '.');
// My name is dongi Oh.

```

- 템플릿 리터럴에서는 `${ }`로 간단하게 표현식 삽입 가능

```jsx
var first = 'dongi';
var last = 'oh';

// ES6: 표현식 삽입
console.log(`My name is ${first} ${last}.`);
// My name is dongi oh.

```

> ${ } 안에 있는 표현식의 결과는 문자열로 자동 변환되어 삽입됨
>

---

## 5. 불리언 타입 (Boolean)

* 값: `true`, `false`
* 조건문에서 프로그램 흐름 제어에 자주 사용

---

## 6. undefined 타입

* 값: `undefined` (유일)
* 개발자가 의도적으로 할당하는 값이 아님
* 변수 선언 후 값이 할당되지 않았을 때 엔진이 자동으로 초기화

---

## 7. null 타입

* 값: `null` (유일)
* 의도적으로 변수에 값이 없음을 명시
* 이전 참조를 제거 → 가비지 컬렉션 대상 됨
* `Null`, `NULL` 등은 전혀 다른 식별자 (대소문자 구분)

---

## 8. 심벌 타입 (Symbol, ES6)

* 변경 불가능한 원시 타입
* 중복 불가, 유일한 값 생성, 생성된 심벌 값 외부 노출 안됨
* 주로 객체의 유일한 프로퍼티 키를 만들기 위해 사용
* Symbol 함수를 호출해 생성 (다른 원시 값은 리터럴을 통해)

```javascript
// 심벌 값 생성
var key = Symbol('key');
console.log(typeof key); // symbol

// 객체 생성
var obj = {};

// 이름이 충돌할 위험이 없는 유일무이한 값인 심벌을 프로퍼티 키로 사용한다.
obj[key] = 'value';
console.log(obj[key]); //value
```

---

## 9. 데이터 타입의 필요성

1. 값을 저장할 때 확보할 **메모리 공간 크기** 결정
2. 값을 참조할 때 읽어들일 **메모리 공간 크기** 결정
3. 메모리에서 읽어들인 **2진수 해석 방법** 결정

### 메모리 처리 예시

```javascript
var score = 100;
```

* 숫자 100 → 숫자 타입으로 해석 → 8바이트 메모리 확보 → 2진수로 저장
* **숫자 타입**은 ECMAScript 명세에 따라 64비트 부동소수점 형식(8바이트) 사용
* 문자열·숫자 외 타입은 엔진 구현에 따라 메모리 크기가 달라질 수 있음

---

## 10. 동적 타이핑

* **정적 타입 언어**: 변수 선언 시 타입 고정 (C, Java 등)
* **동적 타입 언어**: 값 할당 시 타입 결정, 재할당으로 변경 가능 (JavaScript, Python 등)

```javascript
var x = 10;     // number
x = "hello";    // string (타입 변경)
```

* 변수는 타입을 가지지 않음 → **값이 타입을 가짐**
* 장점: 유연성 ↑
* 단점: 신뢰성 ↓ (암묵적 타입 변환, 런타임 오류 발생 가능)

---

## 11. 변수 사용 주의사항

1. 변수 남발 금물 (변수 개수 ↑ → 오류 발생 확률 ↑)
2. 스코프(유효 범위) 최대한 좁게 
3. 전역 변수 지양 (의도치 않은 변경 가능성 ↑)
4. 상수 사용 권장 (값의 변경 억제)
5. 목적이 드러나는 네이밍 필수

---

## 정리

* 데이터 타입은 메모리 크기, 참조 방식, 해석 방법을 결정
* JS는 **동적 타입 언어** → 값이 타입을 가짐, 변수 타입은 유동적
* 유연하지만 신뢰성이 낮으므로 변수 사용에 주의 필요
